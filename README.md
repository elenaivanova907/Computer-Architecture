# Computer-Architecture

Digital Logic Assignment


Elevator Control Logic Circuit Documentation

I circuit is used to power an elevator system with 9 floors, 9 buttons inside the elevator cabin (plus one CLEAR button), and UP and DOWN buttons on almost all floors. Only floor 1 and floor 9 have only one UP or DOWN button respectively. The user can press any input at any time (except an input which is already pressed, as indicated by the LED, which will be ignored). Based on the current floor, the direction of the movement of the elevator, and the exact buttons pressed, the circuit’s processing unit will determine in real time the order in which all requests will be served. The CLEAR button destroys all requests and the elevator stops after serving the last request it received before clearing. 
        The main subcircuit of the elevator system is the “ProcessingUnit”. It functions based on fI stacks which order elements either in ascending or descending order. The stacks themselves function based on unique memory cells (denoted as subcircuit “MemCellDescending” and “MemCellAscending”), which contain the logic for sorting. Like the stack data structure, these stacks only output the topmost element and allow the processing unit to pop this element to remove it. If the top element is popped, all other elements will be bubbled up to fill the empty space. This is done through the use of a decoder and sequencing circuitry (using “TimerCircuit”) which triggers an ordered cascade of commands each time a “Pop” is issued. To understand why fI stacks are needed instead of just one, first the way requests are encoded needs to be explained.   
        Since most commands for the elevator system contain a floor and a requested direction (Floor 9 UP for example), 5 bits are used to encode any command, with the most significant bit storing the direction (0 – Up, 1 – Down) and the rest storing the floor. Commands generated from inside the elevator cabin are first stored in 4 bits. A separate subcircuit called “COP Unit” compares the requested floor to the current floor the elevator is on, and assigns a direction to the command, extending it into 5 bits. Floors 1 and 9 are parsed differently, as they do not need to be compared with the current floor. The only possible direction for floor 1 is up so 0 is added as the MSB, and for floor 9 the only possible direction is down so 1 is added as the MSB. All inputs, including the ones from the cabin after they have been parsed, are passed to the “Input Handler” subcircuit which ensures that input from only the floors or the cabin is passed in at a time to prevent errors in the circuit.
Then, the processing unit analyzes the request and determines which stack to pass it into. Stacks 1 and 3 are reserved for UP requests. If the floor of a request is greater than the current floor, it is passed into stack 1 as it will be served first. If it is smaller, it is passed into stack 3 to be served later. Both stacks 1 and 3 order the requests in ascending order, as the smallest request closest to the current floor must be carried out first. Stacks 2 and 4 are reserved for DOWN requests. If the floor of the request is smaller than the current floor, it is passed into stack 2 as it will be served immediately after stack 1 is finished. If it is bigger, it must be served later so it is passed onto stack 4. Both DOWN stacks are in descending order, as the biggest DOWN request closest to the current floor must be carried out first.
Since the circuit cannot possibly read from all fI stacks at a time, a reading mechanism has been implemented with the use of a counter and a decoder. Each output of the decoder corresponds with one of the stacks, so this output has been denoted as “RHead” (Read-head). To move the read-head from one stack onto another, another decoder is used in the “Stop Mechanism” subcircuit inside “ProcessingUnit”. Whenever the elevator is not in motion, another sequencer called “Read Sequencer” causes the decoder to output commands. The first command outputted is a pop to the current stack being read. Since the elevator has stopped, the request from that stack has been served, so it can be safely popped. Next, the decoder has 3 empty pins so it waits 3 clock cycles before reading from the same stack. This is done because any pop requires at least 2 clock cycles to prepare the stack for another read. After the 3 clock cycles, the current request in the stack is checked again. If it is not 0, it is passed into the simulation unit (denoted as “Counter Subcircuit”) as a destination and the sequencer is reset to check the same stack again after the new request is served. If the request is 0 (meaning all requests in the stack have been served), the read-head is simply incremented by one to check the next stack.
The simulation unit is the “motor” that drives the elevator. In essence, it is a counter circuit which takes the current floor and the destination floor and increments or decrements from the current floor to the destination floor (based on whether the current floor is smaller or bigger than the destination). When the two become equal, a signal is passed to indicate that the elevator has stopped moving. Additional circuitry has also been implemented to pre-set the current floor to 1 upon start (as the default for a register is 0).
        The remaining subcircuits, “IsButtonOn” and “DirectionDisplay”, are simply used to implement the LEDs next to the buttons and the direction display in the user interface.
